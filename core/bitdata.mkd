Types
-----

PureBit is a low-level language, and the data types must reflect this fact.

As such, unboxed data types are fundamental. That is, functions are only valid
when they use data types that decompose into either empty unit types or bit
types.

```
  Types :=
    { Ord := ( (), (Ord) )
    , Bit :=
      { Off
      , On
      }
    , Church := (*) These will be implemented differently for obvious reasons
      { Nat := /\ f . /\ x .
        { 0 := x
        , n ::= f^n x, n > 0           (*) This is syntax sugar to make this
                                       (*) useful. That said,
                                       (*) n := f Nat f x
        }
      , Bool := /\ f . /\ x .
        { True   := f
        , False  := x
        }
      , Ops := /\ f . /\ x .
        { isZero := Nat (/\ y . Bool.False) True
        , ++ := f (Nat f x)
        , +  := Nat f (Nat f x)
        , *  := Nat (Nat f) x
        , -- := Nat (/\g . /\h . h (g f)) (/\u . x) (/\u . u)
        , -  := (Nat --) Nat
        , /  := (/\n . ( (/\f . (/\x . x x) (/\x . f (x x)))
                         (/\c . /\n . /\m . /\f . /\x .
                           (/\d . (/\n . n
                                         (/\x . (/\a . /\b . b))
                                         (/\a . /\b . a))
                                  d
                                  ((/\f./\x.x) f x)
                                  (f (c d m f x)))
                           ( (/\m . /\n . n (/\n ./\f./\x.n (/\g./\h.h (g f)) (/\u.x) (/\u.u)) m) n m)
                         )
                       ) ((/\n . /\f . /\x . f (n f x)) n)
                ) Nat f x
        }
      }
    , Bitdata := Nat ( /\ x . (Bit, x) ) ()
    , *    :=
      /\ a . /\ b . ( (p,q) : A ( p <- a ) ( A ( q <- b ) ( p <- Type
                                                          & q <- Type ) ) )
    , ->   := /\ a . /\ b . /\ f . a <- Type & b <- Type & f < (a * b)
    }
```
