Core Syntax
===========

```
  t ::=                                    (*) terms:
    x                                      (*) variable
    /\ x : T . t                           (*) abstraction
    t t                                    (*) application
    /\ X : K . t                           (*) type abstraction
    t T                                    (*) type application
    t as T                                 (*) type ascription
    { l^i := t^i }                         (*) record, where i <- 1..n.
                                           (*) Elements separated by `,`
    t.l                                    (*) projection
    < l^i := t^i > as T                    (*) tagging, where i <- 1..n (uses
                                           (*) `{ ... }` in external language).
                                           (*) Elements separated by `,`
    case t of < l^i := t1^i > |-> t2^i     (*) case, where i <- 1..n
    { T, t } as T                          (*) packing
    let { X, x } := t in t                 (*) unpacking
    raise t                                (*) raise exception
    try t with t                           (*) handle exceptions

  T ::=                                    (*) types:
    X                                      (*) type variable
    T -> T                                 (*) function type
    A X : K . T                            (*) universal type
    E X : K . T                            (*) existential type
    /\ X : K . T                           (*) operator abstraction
    T T                                    (*) operator application
    { l^i as T^i }                         (*) type of records, where i <- 1..n.
                                           (*) Elements separated by `,`
    < l^i as T^i >                         (*) type of variants, where i <- 1..n
                                           (*) Elements separated by `,`
    Bit                                    (*) bit type

  Bit ::=
      Off                                  (*) off, or bit = 0
      On                                   (*) on, or bit = 1

  K ::=                                    (*) kinds:
    *                                      (*) kind of proper types
    K . K                                  (*) kind of operators

  Y ::=                                    (*) contexts:
    0                                      (*) empty context
    Y, x as T                              (*) term variable binding
    Y, X as K                              (*) type variable binding
```

Notes
-----

Not defined above (for they are fully derived from the above) are the types:
* *Ord.* This is a recursively defined empty record. It functions as a natural
  number type. Operations will be available to make defining vectors
  straightforward.

* *Tuple.* These are defined per Kuratowski's representation of an ordered pair.

* *Area.* This is a tuple of an ordering of pairs and bits, e.g.
  `( (0, Off), (1,Off), (2, On), (3, Off), (4, Off), (5, On) )`,
  which is equivalent to B001001.

Not encoded at the syntax level is the bit data restriction; namely, that all
proper kinds decompose into types composed of bits and/or ordinals. That is,
if the programmer attempts to define a type that is not composed of bits and/or
ordinals, then the source language will not compile. This isn't Haskell, folks!

Finally, I've decided to go ahead and add modular type classes to PureBit.
However, the overloading and instance resolution will occur in the external
language, at least as much as Core will allow.
