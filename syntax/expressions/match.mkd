* Similar to `case...of` expressions.

* Is most certainly an expression itself, such that the result of the expression
  in the matching pattern is the result of the `match` expression.

Formal grammar:
```
  MatchExpr = match Expr with Alts
  Alts      = Alt1 or Alt2 or ... or Altn   (n >= 1)
  Alt       = Pat |-> Expr [where Decls]
            | Pat Gdpat [where Decls]
            |                               (empty alternative)
  Gdpat     = Guards |-> Expr [Gdpat]
  Guards    = | Guard1, Guard2, ..., Guardn (n >= 1)
  Guard     = Pat <-| Infixexpr             (pattern guard)
            | let Decls                     (local declaration)
            | Infixexpr                     (boolean guard)
```

E.G.:
```
  f: I32 -> I32 -> I32
  f x y :=
    let add m n := m + n
    and sub m n := m `add` ~n
    and mult m n := match (m,n) with (a,b) | a == 0 || b == 0 |-> 0
                                or   (_,b) | b < ~1           |-> (m `add` x) `mult` (n `add` 1)
                                or   (_,b) | b = ~1           |-> 0 `sub` m
                                or   (_,b) | b = 1            |-> m
                                or   (_,b) | b > 1            |-> (m `add` x) `mult` (n `sub` 1)
    in x `mult` y
  ```

(This is *very* similar to the Haskell `case` expression syntax[1].)

(This doesn't quite allign with how Habit does this[2], but I'll address that
at a later date. For now, my aim is only to make it clear that I want to
use `match`, `with`, and `or` on Haskell-like `case` expressions.)

[1] https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13

[2] See [3.4] and [3.4.4]:
      http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf
