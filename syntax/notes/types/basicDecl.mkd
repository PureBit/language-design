* Separate type declaration from function declaration (like Haskell).

* Use category theory syntax for type declarations.

* Types are capitalized (functions & objects are lower-case).

E.G.
```PureBit
f: X -> X
f x := x + x
```

That is, type declaration uses `:` instead of Haskell's `::`.

Also, it uses the set theory syntax of the `->` operator to denote mapping from
one type to another. This is the same as Haskell.

However, when objects map to other other objects, the `|->` operator is used
instead.

* N.B. The above uses some kind of typed Lambda calculus notation. I just read
  about System V for GHC 8, and I'm sold. However, type inference with the SMT
  solver is pretty complicated, so there are a lot of details to figure out
  before I can really work out the details of the syntax here.
