Formal Grammar
==============

This document houses the formal grammar of PureBit.

(I have decided to design the language using one FG document to make it easier
for me to keep track of the production rules.)

N.B. I have yet to work out the theoretical elements of PureBit. Until that
hard work is done, everything here is mere suggestion.

Credit
------

I want to make it *very* clear here that this document is *very* indebted to
the Preliminary Habit Report[1]. Much of the following is ripped straight out
of it with little modification.

Notation
--------

This document uses the notation conventions of the Habit Report[2].

Specifically:
* Nonterminal symbols are written with an initial capital letter.

* Keywords are written in lowercase.

* The following is the set of all notational symbols: {`|` `(` `)` `,` `=`}
  (spaces denote a separator). To represent terminals that use the same symbol,
  they will be encased in double quotes, e.g. ",".

  N.B. The one exception to this are comments. When their production rules are
  declared, the terminals will also be enclosed in quotes to prevent confusion.

  Roughly, these denote the following:

  ```
  "|"   = (* XOR *)
  "("   = (* begin parameter *)
  ")"   = (* end parameter *)
  ","   = (* separate parameters *)
  "="   = (* production rule *)
  ```

* Grammar rules are written:

  ```
  N = rhs1
    | ...
    | rhsn
  ```

  where `n` is a nonterminal name and each right hand side (rhs) is a sequence
  of symbols corresponding to a production. Each production may span multiple
  lines so long as all the of the symbols are indented to the right of the
  initial `=` or `|`.

* Fragments of grammar are annotated using SuccessorML commenting convention:
  a `(*)` sequence introduces a one line comment that extends to the end of the
  line on which it appears and a `(* ... *)` pair provides a nested comment that
  may span multiple lines.

* For clarity, `(* empty *)` is used to indicate an empty rhs.

* Some productions terminate with a description encapsulated in a comment.

* Parameterized grammar definitions are allowed, i.e. the definition of a
  nonterminal may be annotated with one or more formal parameters, written with
  the initial upper case letter, enclosed in parentheses, and separated by
  commas. Each use of a parameterized nonterminal in the right hand side of a
  production should specify a sequence of symbols to be substituted by the
  corresponding formal parameter. Below are some common patterns:

  ```
  Opt(X)       = (* empty *)   (*) optional X
               | X
  Choice(X,Y)  = X             (*) either X or Y
               | Y
  Group(X,Y)   = X S           (*) groups productions (useful for Diff)
  Combine(X,Y) = XY            (*) explicitly combines productions
  List(X)      = X             (*) one of more Xs
               | X List(X)
  ListO(X)     = Opt(List(X))  (*) zero or more Xs
  Dif(X,Y)     = Z             (*) special: X \ Y
  Sep(X,S)     = X             (*) one or more Xs separated by S
               | X S Sep(X,S)
  SepO(X,S)    = Opt(Sep(X,S)) (*) zero or more Xs separated by S
  Sep2(X,S)    = X S Sep(X,S)  (*) two or more Xs separated by S
  ```

  Parameterized rules like these are interpreted as macros for generating
  productions, and the grammar is only valid if the process of macro expansion
  is guaranteed to terminate. For example, the following definition for `Inv`
  is not valid[3]:

  ```
  Inv(X) = X Inv(Inv(X))  (*) invalid!
  ```

  On the other hand, the next definition, for `Inf`, is technically valid,
  but not useful in practice becaue it does not derive any finite strings:

  ```
  Inf(X) = X Inf(X)
  ```

Lexical Syntax
--------------

* PureBit uses the Unicode character set[4].

* The syntax is highly influenced by Haskell[5]. I will only write production
  rules for syntax that's different from that of Haskell.

  N.B. I do plan, though, to write a full grammar once I've finished
  designing the whole language and feel that it is starting to stabilize. That
  day is *not* today :)

* *Comments.*

  Comments can be nested, e.g.

  ```
  (*) All three comment blocks are commented out, as the upper level is not
  (*) closed off prematurely at the first *) right after the second comment
  (*) block -- as you would expect in, say, C.
  (* (*) Begin upper level
  [Comment block]
  (* (*) Begin second level
  [Comment block]
  *) End second level
  [Comment block]
  *) End upper level
  ```

  The syntax is that of SuccessorML: `(*)` denotes a single line comment that
  begins at the `(*)` and terminates at the end of the line it was declared on;
  `(* ... *)` denotes a comment block that can span multiple lines, beginning
  at `(*` and terminating at `*)` (per the above, comments can be nested with
  single line comments & further comment blocks).

* *Literate files.*

  While not formally part of the language, PureBit implementations are
  expected to support the use of literate files, most likely matching the
  syntax of Literate Haskell.

  In practice, PureBit implementations will distinguish between literate
  and regular source code with the use of an `l` in the source file suffix.

* *Integer Literals.*

  Largely follows the syntax of Haskell, but adopts the following extensions:
  * *Binary literals.*
    In addition to decimal literals, hexadecimal literal (beginning with `0x`
    or `0X` and followed by a sequnce of hexadecimal digits), and octal
    literals (beginning with `0o` or `0O` and followed by a sequence of octal
    literals), PureBit allows binary literal that being wither `0b` or `0B` and
    are followed by a sequence of one of more binary digits.

  * *Underscores.*
    PureBit allows underscore character to be included at any point in an
    integerAliteral (after the initial prefiex that specifies a radix, if
    present). This can increase the readability of long literals, but are
    otherwise ignored.

  * *Literal suffixes.*
    A single `K`, `M`, `T`, or `P` may be added to a numeric literal to denote
    a multiplier of 2^10 (kilo-), 2^20 (mega-), 2^30 (giga-), 2^40 (tera-),
    and 2^50 (peta-). Note the binary interpretations of these suffixes.

* *Layout.*

  PureBit uses a layout rule, as in Haskell, to allow automatic insertion of
  the punctuation that is used for lists of declarations, alternatives,
  statements, etc. Until I work out the full grammar, though, it is premature
  to describe the details of the rule.

  That being said, I plan on using `and`, `or`, and `end` to control scope,
  rather than `{`, `}`, and `;`.

Kinds and Types
---------------

N.B. I have yet to develop the type system, and so this section is very sparse.
That said, I do have some strong sympathies:
* PureBit needs to be safe, but be able to execute without a run time.
  Accordingly, I want to have as strong a type system as possible, while
  retaining type checking and type inference. I feel that Dependent
  Haskell[6] achieves this balance. However, given as I don't need to worry
  about backwards compatibility, I plan to play with the more conservative
  design of DP.

* I want PureBit to also have a powerful module system. However, I'm really
  torn about the design:
  * I like the way that SML separates signatures, modules, and functors.
    However, it doesn't support overloading functions very well, and that's
    a pretty killer feature of Haskell's. That said, I do like the mathematical
    purity and elegance of the design. Perhaps it is possible to have my
    cake and eat it, too?[7]

  * Haskell type classes rock ad hoc polymorphism, and allow for much of the
    power of the SML module system, but are more practical. However,
    they have some limitations relative to SML's module system, one such
    being issues with APIs[8]. This is a known problem, with a known solution:
    Backpack[9]. Perhaps that would be the better way to go?

  I will have to play around with this, see which I prefer in practice.
  My gut says #2, as the features I am most interested in have already been
  worked out in Haskell and are thoroughly battle-tested by the Haskell
  community.

* I *really* like Cayenne's radical simplifications. To the extent it is
  possible, I want to use Cayenne's syntax & semantics[10]. However, my
  sense is that there are severe limitations there, as it seems that
  its first-class records rely on dependent typing - and I'm not sure
  that Dependent Haskell will similarly allow for that kind of flexibility.
  I'll have to work this out.

  Update: from what I've read, it seems like it will be able to. I'll have to
  see how well this works in practice.

* Overall, PureBit strongly builds on the work done on Haskell these past 20
  years, but targets the low-level domain.

Declarations
------------

This section covers the (admittedly sparse) declaration syntax of PureBit.

* Function declaration is more mathematical. In Haskell, you would write the
  `LiftM2` function as follows[11]:

  ```Haskell
  liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c
  liftM2 op mx my = do
    x <- mx
    y <- my
    return (x `op` y)
  ```

  The mathematical notation is something like:

  ```
  liftM2 op m1 m2 := /\a. /\b. /\c. /\d
                  .  \x. \y. \z
                  :  (a -> b -> c) -> M a -> M b -> M c where M: monad
                  :  bind (M x) (x |-> bind (M y) (y |-> return (f x y)))
                     where f = (* some binary function *)
  ```

  (Where `/\` is a big lambda, `\` is a little lambda, `.` is lambda
  application, `:` is the typed lambda calculus notation for "has type of",
  `:=` is definition notation, and `|->` is a mapping).

  What I have in mind is to radically simplify the mathematical notation:

  ```PureBit
  liftM2 op mx my := (a -> b -> c) -> m a -> m b -> m c where m: Monad
                  :  do x <- mx
                        y <- my
                        return (x `op` y)
  ```

  This declaration syntax segregates types and values, but keeps them
  together in the same declaration. This makes functions self-documenting.
  This seems like a sweet marriage of Haskell's and ML's type syntax.

  Further, as PureBit will have type inference, declarations can be
  simplified:

  ```PureBit
  liftM2 op mx my := do x <- mx
                        y <- my
                        return (x `op` y)
  ```

* *Anonymous function.*

  PureBit uses Haskell's `\` lambda operator, but uses `.` instead of the
  `->` operator. Otherwise, the syntax for anonymous functions is identical.

  For example:

  ```PureBit
  f x := let g := \ y z . y + z
         and h := \ a b . a - b
         and i := \ g o h
          in i x x x
  ```

* *Function composition.*

  I prefer to use the `.` symbol as the lambda application operator rather
  than function composition. However, as composition is so vital, the letter
  `o` is reserved as a special infix function for composition.

* *Let expressions.*

  These have the general form `let Decl1 and Decl2 and ... Decln in Expr`.
  and introduce a nested, lexically-scoped, mutually-recursive list of
  declarations (`let` is often called `letrec` in other languages). The scope
  of the declarations is the expression `Expr` and the rhs of the declarations.

  N.B. Full function declarations can be made, type signature and all. E.G.

  ```PureBit
  f x := let g n := a -> a -> a
                 :  \ y . n + y
          in g x x
  ```

* PureBit allows for `where` clauses, but they are a little different:
  ** They can be inserted into both the type declaration and the function
     declaration.

  ** If inserted at the end of a type declaration, they can be used for
     aliasing that is scoped for the entire function, to assert instantiation
     of a type in a type class, and all of the other type related declarations.

  ** If inserted at the end of a function declaration, they can do everything
     Haskell `where` clauses can do.

* Case expressions use a slightly different syntax than Haskell. Namely:

  ```PureBit
  f x := match x with 0 -> 1
                 or   1 -> 2
                 or   2 -> 3
  ```

  Of course, it's possible to use light-weight syntax for an implicit `or`:

  ```PureBit
  f x := match x with 0 -> 1
                      1 -> 2
                      2 -> 3
  ```

  My sympathy is towards making the expression more readable, but
  giving the programmer a way eliminate unnecessary code.

* In general, I prefer `and`s and `or`s and `end`s over braces and semicolons.

Footnotes
---------

[1]   http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf

[2]   See page 8.

[3]   I'm actually not clear on why `Inv` is not valid.

[4]   http://unicode.org/standard/standard.html

[5]   https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002

[6]   https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell

[7]   http://www.cs.cmu.edu/~rwh/papers/mtc/full.pdf

[8]   http://blog.ezyang.com/2014/08/the-fundamental-problem-of-programming-language-package-management/

[9]   http://plv.mpi-sws.org/backpack/index.html

[10]  http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf

[11]  https://en.wikipedia.org/wiki/Monad_(functional_programming)#Generic_monadic_functions
