System PB Syntax
================

System PB is just (a strictly evaluating) System F-Omega with a
few extensions:
* Ascription
* Records
* Variants
* Existential types
* Impredicativity
* Recursion
* Exceptions

N.B. This gets me *very* close to where I want to go with PureBit. That said,
there is one glaring question: can this support implicit functions, giving
PureBit modular type classes? I have spoken with both Dreyer & Rossberg, and
they strongly believe that it is. However, until they release a paper proving
that this is so, I am just going to stick to explicit modules (if they take too
long, I'll just try to do so myself).

```
  t ::=                                    (*) terms:
    x                                      (*) variable
    /\ x : T . t                           (*) abstraction
    t t                                    (*) application
    /\ X : K . t                           (*) type abstraction
    t T                                    (*) type application
    t : T                                  (*) type ascription
    { l^i := t^i }                         (*) record, where i <- 1..n
    t.l                                    (*) projection
    { T, t } : T                           (*) packing
    let { X, x } := t in t                 (*) unpacking
    < l^i := t^i > : T                     (*) tagging, where i <- 1..n (uses
                                           (*) `{ ... }` in external language)
    case t of < l^i := x^i > -> t^i        (*) case, where i <- 1..n
    wrap X : T                             (*) impredicativity
    unwrap X : T                           (*) impredicativity
    fix t                                  (*) general recursion
    raise t                                (*) raise exception
    try t with t                           (*) handle exceptions

  v  : :=                                  (*) values:
    /\ x : T . t                           (*) abstraction value
    /\ X : K . t                           (*) type abstraction value
    { l^i  : = v^i }                       (*) record value, where i <- 1..n
    { T, t } : T                           (*) package value

  T  : :=                                  (*) types:
    X                                      (*) type variable
    T -> T                                 (*) function type
    A X : K . K                            (*) universal type
    E X : K . K                            (*) existential type
    /\ X : K . K                           (*) operator abstraction
    T T                                    (*) operator application
    { l^i : T^i }                          (*) type of records, where i <- 1..n
    wrap T                                 (*) impredicativity

  K  : :=                                  (*) kinds:
    *                                      (*) kind of proper types
    K -> K                                 (*) kind of operators

  Y  : :=                                  (*) contexts:
    0                                      (*) empty context
    Y, x : T                               (*) term variable binding
    Y, X : K                               (*) type variable binding
```
