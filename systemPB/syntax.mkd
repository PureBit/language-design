System PB Syntax
================

System PB is just (a strictly evaluating) System F-Omega with a
few extensions:
* Ascription
* Records
* Variants
* Existential types
* Impredicativity
* Recursion
* Exceptions

N.B. ~~This gets me *very* close to where I want to go with PureBit. That said,
there is one glaring question: can this support implicit functions, giving
PureBit modular type classes? I have spoken with both Dreyer & Rossberg, and
they strongly believe that it is. However, until they release a paper proving
that this is so, I am just going to stick to explicit modules (if they take too
long, I'll just try to do so myself).~~ Actually, this *does* get me everything
that I want. Of course, I will have to figure out overloading and instance
resolution in the source language, but I'm confident I'll figure it out.

```
  t ::=                                    (*) terms:
    x                                      (*) variable
    /\ x : T . t                           (*) abstraction
    t t                                    (*) application
    /\ X : K . t                           (*) type abstraction
    t T                                    (*) type application
    t as T                                 (*) type ascription
    { l^i := t^i }                         (*) record, where i <- 1..n
    t.l                                    (*) projection
    { T, t } as T                          (*) packing
    let { X, x } := t in t                 (*) unpacking
    < l^i := t^i > as T                    (*) tagging, where i <- 1..n
    case t of < l^i := x^i > |-> t^i       (*) case, where i <- 1..n
    raise t                                (*) raise exception
    try t with t                           (*) handle exceptions

  T ::=                                    (*) types:
    X                                      (*) type variable
    T -> T                                 (*) function type
    A X : K . K                            (*) universal type
    E X : K . K                            (*) existential type
    /\ X : K . K                           (*) operator abstraction
    T T                                    (*) operator application
    { l^i : T^i }                          (*) type of records, where i <- 1..n
    < l^i : T^i >                          (*) type of variants, where i <- 1..n

  K ::=                                    (*) kinds:
    *                                      (*) kind of proper types
    K -> K                                 (*) kind of operators

  Y ::=                                    (*) contexts:
    0                                      (*) empty context
    Y, x : T                               (*) term variable binding
    Y, X : K                               (*) type variable binding
```
