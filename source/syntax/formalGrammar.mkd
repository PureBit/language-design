Formal Grammar
==============

This document houses the formal grammar of PureBit.

Credit
------

I want to make it *very* clear here that this document is *very* indebted to
the Preliminary Habit Report[1] and the Haskell 2010 Report[2]. A lot of the
following is ripped straight out of the two with little modification.

Notation Conventions
--------------------

* The following conventions are used to present syntax:

  ```
  [Pattern]           (* optional *)
  {Pattern}           (* zero or more repetitions *)
  (Pattern)           (* grouping *)
  Pattern1 | Pattern2 (* choice *)
  Pattern<Pattern'>   (* difference: elements generated by Pattern, except *)
                       * those generated by Pattern' *)
  term                (* terminal syntax *)
  Nonterm             (* production *)
  ```

* Because the syntax describes lexical syntax, all whitespace is expressed
  explicitly; there is no implicit space between juxtaposed symbols.

* BNF-like syntax is used throughout, with productions having the form:

  ```
  Nonterm   ->  Alt1 | Alt2 | ... | Altn
  ```

* Each production may span multiple lines so long as all the of the symbols
  are indented to the right of the initial `->` or `|`.

* Care must be taken to distinguish metalogical symbols such as `|` and
  `[...]` from concrete terminal syntax. This distinction is made explicit by
  surrounding the concrete terminals in double quotes, e.g. `"|"`.

* PureBit uses the Unicode character set[3].

* Fragments of grammar are annotated using comment syntax from SuccessorML
  commenting convention (described below).

* Some productions terminate with a description encapsulated in a comment,
  e.g. `(* empty alternative *)`.

Lexical Syntax
--------------

The syntax is highly influenced by Haskell. I will only write production
rules for syntax that's different.

N.B. I do plan, though, to write a full grammar once I've finished
designing the whole language and feel that it is starting to stabilize. That
day is *not* today, though :)

* *Comments.*

  Comments can be nested, e.g.

  ```
  (*) All three comment blocks are commented out, as the upper level is not
  (*) closed off prematurely at the first *) right after the second comment
  (*) block -- as you would expect in, say, C.
  (* (*) Begin upper level
  [Comment block]
  (* (*) Begin second level
  [Comment block]
  *) End second level
  [Comment block]
  *) End upper level
  ```

  The syntax is that of SuccessorML: `(*)` denotes a single line comment that
  begins at the `(*)` and terminates at the end of the line it was declared on;
  `(* ... *)` denotes a comment block that can span multiple lines, beginning
  at `(*` and terminating at `*)` (per the above, comments can be nested with
  single line comments & further comment blocks).

  Formal grammar for comments:

  ```
  Program     -> { Lexeme | Whitespace }
  Whitespace  -> Whitestuff { Whitestuff }
  Whitestuff  -> Whitechar | Comment | Ncomment
  Whitechar   -> (* whitespace characters, e.g. tab *)
  Newline     -> (* newline characters, e.g. carriage return *)
  Comment     -> Closedstar { Any< Newline > } Newline
  Closedstar  -> "(*)"
  Ncomment    -> Opencom Anyseq { Ncomment Anyseq } Closedcom
  Opencom     -> "(*"
  Closedcom   -> "*)"
  Anyseq      -> { Any }< { Any } ( Opencom | Closedcom ) { Any } >
  Any         -> Graphic | Whitechar
  Graphic     -> (* letters, numbers, etc. *)
  ```

  Parsers will have to read one character farther when they come across
  a nested `Opencom`, as it might be a legal `Closedstar`.

* *Literate files.*

  While not formally part of the language, PureBit implementations are
  expected to support the use of literate files, most likely matching the
  syntax of Literate Haskell.

  In practice, PureBit implementations will distinguish between literate
  and regular source code with the use of an `l` in the source file suffix.

* *Integer Literals.*

  Largely follows the syntax of Haskell, but adopts the following extensions:
  * *Binary literals.*
    In addition to decimal literals, hexadecimal literal (beginning with `0x`
    or `0X` and followed by a sequnce of hexadecimal digits), and octal
    literals (beginning with `0o` or `0O` and followed by a sequence of octal
    literals), PureBit allows binary literal that being wither `0b` or `0B` and
    are followed by a sequence of one of more binary digits.

  * *Underscores.*
    PureBit allows underscore character to be included at any point in an
    integer literal (after the initial prefix that specifies a radix, if
    present). This can increase the readability of long literals, but are
    otherwise ignored.

  * *Literal suffixes.*
    A single `K`, `M`, `T`, or `P` may be added to a numeric literal to denote
    a multiplier of 2^10 (kilo-), 2^20 (mega-), 2^30 (giga-), 2^40 (tera-),
    and 2^50 (peta-). Note the binary interpretations of these suffixes.

  Formal grammar for numeric literals:

  ```
  Digit       -> 0 | 1 | ... | 9
  Octit       -> 0 | 1 | ... | 7
  Hexit       -> Digit | A | ... | F | a | ... | f
  Binit       -> 0 | 1

  Decimal     -> Digit { Digit }
  Octal       -> Octit { Octit }
  Hexadecimal -> Hexit { Hexit }
  Binary      -> Binit { Binit }

  Suffix      -> K | M | T | P
  Underscore  -> _
  Dec         -> { Decimal | Underscore | Dec }
  Hex         -> { Hexadecimal | Underscore | Hex }
  Oct         -> { Octal | Underscore | Oct }
  Bin         -> { Binary | Underscore | Bin }

  Integer     -> { Suffix } Int
  Int         -> Decimal { Dec }
              |  0o Octal { Oct } | 0O Octal { Oct }
              |  0x Hexadecimal { Hex } | 0X Hexadecimal { Hex }
              |  0b Binary { Bin } | 0B Binary { Bin }

  Float       -> Decimal . Decimal [ Exponent ]
              |  Decimal Exponent

  Exponent    -> ( e | E ) [ + | - ] Decimal
  ```

  I still haven't made up my mind about negative numbers. Is it better to have
  a unary negative function or use `~` to denote negativity? I don't know.

* *Layout.*

  PureBit uses a layout rule, as in Haskell, to allow automatic insertion of
  the punctuation that is used for lists of declarations, alternatives,
  statements, etc. Until I work out the full grammar, though, it is premature
  to describe the details of the rule.

  That being said, I plan on using `and`, `or`, and `end` to control scope,
  rather than `{`, `}`, and `;`.

General Notes
-------------

* I prefer `and`s and `or`s and `end`s over braces and semicolons.
  Admittedly, the latter is simpler, requiring only three lexemes. However,
  the former feels more intuitive to me - and parsing it is really no big deal.

Kinds and Types
---------------

N.B. I have yet to develop the type system, and so this section is very sparse.
That said, I do have some strong sympathies:
* PureBit needs to be safe, but be able to execute without a run time.
  Accordingly, I want to have as strong a type system as possible, while
  retaining type checking and type inference. I feel that Dependent
  Haskell[4] achieves this balance. However, given as I don't need to worry
  about backwards compatibility, I plan to play with the more conservative
  design of DP.

* I want PureBit to also have a powerful module system. However, I'm really
  torn about the design:
  * I like the way that SML separates signatures, modules, and functors.
    However, it doesn't support overloading functions very well, and that's
    a pretty killer feature of Haskell's. That said, I do like the mathematical
    purity and elegance of the design. Perhaps it is possible to have my
    cake and eat it, too?[5]

  * Haskell type classes rock ad hoc polymorphism, and allow for much of the
    power of the SML module system, but are more practical. However,
    they have some limitations relative to SML's module system, one such
    being issues with APIs[6]. This is a known problem, with a known solution:
    Backpack[7]. Perhaps that would be the better way to go?

  I will have to play around with this, see which I prefer in practice.
  My gut says #2, as the features I am most interested in have already been
  worked out in Haskell have been thoroughly vetted by the Haskell community.

* I *really* like Cayenne's radical simplifications. To the extent it is
  possible, I want to use Cayenne's syntax & semantics[8]. However, my
  sense is that there are severe limitations there, as it seems that
  its first-class records rely on dependent typing - and I'm not sure
  that Dependent Haskell will similarly allow for that kind of flexibility.
  I'll have to work this out.

  Update: from what I've read, it seems like it will be able to. I'll have to
  see how well this works in practice.

* PureBit strongly builds on the work done on Haskell these past 20 years, but
  targets the low-level domain. I am not quite sure how to best do that. Once
  I've worked out the internal language (some System FC variant), I'll have to
  play around with Habit's syntax and figure out how to adapt it.

Declarations and Bindings
-------------------------

This section covers the (admittedly sparse) declaration and binding syntax
of PureBit.

* Function declaration is pretty much identical to Haskell, with only minor
  differences.

  Example[9]:

  Haskell:

  ```Haskell
  liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c
  liftM2 op mx my = do
    x <- mx
    y <- my
    return (x `op` y)
  ```

  PureBit:

  ```PureBit
  liftM2: m:Monad. (a -> b -> c) -> m a -> m b -> m c
  liftM2 f mx my := do x <- mx
                       y <- my
                       return (x `op` y)
  ```

  After playing around with the mathematical notation of System F, I realized
  that Haskell's syntax is incredibly elegant:

  To see this, consider the "full" mathematical notation (or thereabouts):

  ```
  liftM2 :=  /\a. /\b. /\c. /\m^(Monad)
         .   \f^(a -> b -> c). \mx^(m a). \my^(m b)
         .   f |-> mx |-> my
         |-> bind mx (x |-> bind my (y |-> return (f x y)))
         :   forall a. forall b. forall c. forall m
         .   (a -> b -> c) -> (m a) -> (m b) -> (m c)
  ```

  Obviously, this is incredibly unwieldy. That said, a lot of it can be left
  implicit:

  ```
  liftM2 :=  f |-> mx |-> my
         |-> bind mx (x |-> bind my (y |-> return (f x y)))
         :   m^(Monad). (a -> b -> c) -> (m a) -> (m b) -> (m c)
  ```

  Further, the declaration's type signature can be split from it
  as syntactic sugar:

  ```
  liftM2 :=  f |-> mx |-> my
         |-> bind mx (x |-> bind my (y |-> return (f x y)))

  liftM2 :   m^(Monad). (a -> b -> c) -> (m a) -> (m b) -> (m c)
  ```

  Given that declarations always occur in mutually-recursive domains, it's
  possible to rewrite the above as

  ```
  liftM2 :   m^(Monad). (a -> b -> c) -> (m a) -> (m b) -> (m c)
  liftM2 :=  f |-> mx |-> my
         |-> bind mx (x |-> bind my (y |-> return (f x y)))
  ```

  Another syntactic flourish moves the mappings to the declaration:

  ```
  liftM2: m^(Monad). (a -> b -> c) -> (m a) -> (m b) -> (m c)
  liftM2 f mx my := bind mx (x |-> bind my (y |-> return (f x y)))
  ```

  Throw in monadic `do` notation, backticked infixing, and the `$` function,
  and you get the following:

  ```PureBit
  liftM2: m^(Monad). (a -> b -> c) -> (m a) -> (m b) -> (m c)
  liftM2 f mx my := do x <- mx
                       y <- my 
                       return $ x `f` y
  ```

  N.B. Just like Haskell, PureBit will have type inference, so type
  signatures can usually be left out:

  ```PureBit
  liftM2 f mx my := do x <- mx
                       y <- my
                       return (x `f` y)
  ```

  It's hard to nail down the formal grammar of this, as I still haven't
  worked out the type system. That said, it is roughly like the following:

  ```
  Decl       -> Gendecl
             |  ( Funlhs | Pat ) Rhs

  Gendecl    -> Var : [ Context ] Type
             |  Fixity [ Integer ] Ops
             |  (* empty *)

  Context    -> Tyvars ^ Openparen Class Closeparen . { Context }
  Tyvars     -> Varid
  Varid      -> ( Small { Small | Large | Digit | ' } )< Reservedid >
  Small      -> (* a, b, ..., z, _ *)
  Large      -> (* A, B, ..., Z *)
  Reservedid -> (* keywords, e.g. match *)
  Openparen  -> "("
  Closeparen -> ")"

  Class      -> (* still working on this *)
  Type       -> (* still working on this *)

  Fixity     -> infixl | infixr | infix
  Ops        -> Op1, ..., Opn (* n >= 1 *)
  Op         -> Varop | Conop

  Funlhs     -> Var Apat { Apat }
             |  Pat Varop Pat
             |  ( Funlhs ) Apat { Apat }
  Rhs        -> := Exp [ where Decls ]
             |  Grdhs [ where Decls ]
  ```

  Many of the above productions are not worked through to a terminal, as there
  is still a lot to figure out with respect to those.

* *Anonymous function.*

  PureBit uses Haskell's `\` lambda operator, but uses `.` instead of the
  `->` operator. Otherwise, the syntax for anonymous functions is identical.

  For example:

  ```PureBit
  f x := let g := \ y . y * 1
         and h := \ z . 2 - b
         and i := g `of` h
          in i x
  ```

  The formal grammar is simple enough:

  ```
  Lexp    -> \ Apat1 ... Apatn . Exp
  ```

  The production rules for `Lexp`, etc., though are still in progress.

  N.B. One major implication of this is that I can't use `.` for function
  composition anymore. I'll have to think on what to do instead, but I think
  that an explicit `\`of\`` makes sense: it's short enough to use frequently,
  and is how many people speak when they talk about composing functions, e.g. 
  "f of g". Note the backticks, making it consistent with the syntax for all
  other non-symbol infix expressions.

* *Let expressions.*

  These have the general form `let Decl1 and Decl2 and ... Decln in Expr`.
  and introduce a nested, lexically-scoped, mutually-recursive list of
  declarations (`let` is often called `letrec` in other languages). The scope
  of the declarations is the expression `Expr` and the rhs of the declarations.

  N.B. Full function declarations can be made, type signature and all. E.G.

  ```PureBit
  f x := let g n := a -> a -> a
                 :  \ y . n + y
          in g x x
  ```

  Note that light-weight syntax can infer the `and`s.

  The formal syntax:

  ```
  Lexp   -> let Ldecls in Exp
  Ldecls -> Decl { and Ldecls }
  ```

* *Where clauses.*

  `where` clauses are, like `let` declarations, mutually recursive, et al.

  Also, each clause is separated by an `and`, which can be implicit if using
  light-weight syntax.

  Explicit example:

  ```PureBit
  f x := g `of` h $ x
    where g x := 3 * x
    and   h x := x `div` 2
  ```

  Implicit example:

  ```PureBit
  f x := g `of` h $ x
    where g x := 3 * x
          h x := x `div` 2
  ```

  Formal grammar:

  ```
  Wheres      -> where Whereclause { and Whereclause }
  Whereclause -> Exp
  ```

  N.B. `where` is used all over the place, hence it's tricky to write out
  it's full FG without working out the FG for the whole language.

* Case expressions are very similar to Haskell's, except they are called
  `match ... with` and the clauses are separated by an `or`.

  Explicit example:

  ```PureBit
  f x := match x with 0 -> 1
                   or 1 -> 2
                   or 2 -> 3
  ```

  Of course, it's possible to use light-weight syntax for an implicit `or`:

  ```PureBit
  f x := match x with 0 -> 1
                      1 -> 2
                      2 -> 3
  ```

  The formal grammar:

  ```
  Lexp    -> match Exp with { Alts }
  Alts    -> Alt { or Alt }
  ```

  N.B. Obvoiusly, I still haven't worked out the `Alt` productions.

Footnotes
---------

[1]   http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf

[2]   https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002

[3]   http://unicode.org/standard/standard.html

[4]   https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell

[5]   http://www.cs.cmu.edu/~rwh/papers/mtc/full.pdf

[6]   http://blog.ezyang.com/2014/08/the-fundamental-problem-of-programming-language-package-management/

[7]   http://plv.mpi-sws.org/backpack/index.html

[8]  http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf

[9]  https://en.wikipedia.org/wiki/Monad_(functional_programming)#Generic_monadic_functions
