Type Signatures
---------------

```
  MAP :=
    { Key := Type.*
    , Map := /\ a .
      { Null := Type.Unit.()
      , a -> List a
      }
    , empty := /\ a . (Map a).Null
    , add := /\ a . Function (Key * a * Map a) (Map a)
    , lookup := /\ a . Function (Key * Map a) (Opt a)
    }
```

Ascription:

```
  MapInt := { x : A (x <- MAP) ( x = Key
                               | x = Map Int
                               | x = empty Int
                               | x = add Int
                               | x = lookup Int
                               ) }
```

It might help to use a keyword, e.g. `as`, for syntax sugar:

```
  MapInt as Map :=
    { Map := Map Int
    , empty := empty Int
    , add := add Int
    , lookup := lookup Int
    }
```

(Don't have to explicitly define identical values.)

Note that for function elements, they will need to have their function tuples
added, too, in order for them to be useful. However, this isn't necessary,
and the programmer can keep the set general.
