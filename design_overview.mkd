Design Overview
===============

This document gives a rough overview of the design of PureBit.

Motivation
----------

The following are PureBit's must-have features:
* Efficient

* Expressive

* Implicit types (perhaps not full type inference, but definitely some)

* Strongly typed

* Memory safe

* Purely functional

* State handled with monads

* Ad-hoc polymorphism

* Parametric polymorphism

* Low-level

* Eager evaluation

* First class modules with interfaces

* A foreign function interface (this subverts type check guarantees, but it
  opens up all of the C libraries that a low-level language needs access to)

Design Plan
-----------

The basic compiler design:
* Parse PureBit source (Source)

* Rename Source

* Type check Source

* Desugar Source into an explicitly typed internal language (Core)

* Optimize Core

* Code generation (either bytecode for the interpreter or LLVM IR for
  binary compilation)

Core
----

Core is the beating heart of PureBit, as Source desugars fully into Core. If
a feature cannot be expressed in Core, it cannot be expressed in Source.

Engineering Plan
----------------

The idea is to start off designing Core, then build for it a type checker
(because it's an intermediary language, I would not need a parser for it,
as it will be receiving an AST directly).

Next, I design Source, such that every construct desugars into Core. With
that done, I build a parser, a renamer, a type checker with type inference, and
a compiler to Core.

Finally, I build an LLVM code generator to make Core useful.

This will give me PureBit 0.0.1. Using it, I then self-host, build an optimizer,
and a linter.
