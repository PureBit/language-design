Design Overview
===============

This document gives a rough overview of the design of PureBit.

Motivation
----------

The following are PureBit's primary features:
* Efficient
* Expressive
* Safe
* Strongly typed
* Purely functional
* State handled with monads
* Low-level data types
* Eager evaluation
* Modular with interfaces

I feel that MPJ was on the right track with Habit, and see PureBit as a
spiritual successor to that project.

Feature Set
-----------

PureBit is essentially a cross between Dependent Haskell & Habit, plus Backpack
as it's module system.

The full list:
* System FC with explicit kind equality as the intermediate language.

  This is modified with the inclusion of Habit's kinds.

* Syntax & semantics for the source language are based on Habit and Haskell.

  Things like memory update is done via monads.

* Add Dependent Haskell features (e.g. GADTs) to the language, so that they
  are not just exotic extensions.

* I will use a variant of the Backpack module system to give the language
  full-blooded separate module development capability.

Types System
------------

I initially wanted dependent types for PureBit. Primarily, this was because they
make it possible to type check what would otherwise be unsafe code, and in so
doing guarantee safety at compile time. Not only would this allow programs
to be maximally efficient, they could also allow programs to be proven correct.

However, dependent types have serious disadvantages, as they are significantly
more complicated.

Habit's type system, with its multiple kinds, allows PureBit to have all of the
features that I really care about in dependently typed languages, without the
costs.

Further, it's trivial to add Habit's kinds to the System FC variant with
explicit kind equality. While it doesn't provide for all of the features
a full dependent type system gives, as in Agda, this gives me *a lot* of
fancy types (e.g. promotable GADTs).

Finally, type checking is decideable and performed in linear time, and type
inference is possible in most cases. As with GHC, the source language is
primarily implicitly typed (exceptions exist, but they are rare). This
makes for a much more pleasant coding experience.

Systems Programming
-------------------

PureBit is designed primarily for low-level systems programming.

In this regard it borrows *very* heavily from Habit.

For one, Habit is the only pure, functional, statically & strongly typed,
strictly evaluated, low-level programming language that I know of.

Not only that, I feel that the solutions developed in Habit are fantastic,
and revivew them in PureBit gladly.

